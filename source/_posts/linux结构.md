---
title: linux结构
tags:
  - linux
date: 2021-03-28 13:36:25
top:
---

### 基本结构

![image-20210328133652101](https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210328133652101.png)

#### VFS层

就是看你对哪个目录中的文件执行的磁盘io操作，把io请求交给具体的文件系统

#### Page Cache

在这个page cache 基于内存的缓存里找你要的数据在不在里面，如果有就基于内存缓存来执行读写，如果没有就继续往下一层走，此时这个请求会交给通用的block层，在这一层会把你对文件的io请求转换为Block IO请求

#### IO调度层

这一层里默认的是用CFQ公平调度算法，也就是说，可能有两个sql请求同时过来，一个比较简单，只是更新磁盘的一个block的数据就可以了，另外一个是读取一个表中的所有数据，如果基于这个默认的CFQ算法，就会让读全表的这个sql先执行，更新一个条数据的sql等到读全表的sql全部执行结束之后才能执行。这样会导致明明应该先执行简单地操作，结果复杂的反而先执行了，不符合我们的预期

于是，在mysql的生产环境，建议采用deadline iO调用算法。它的一个核心思想就是，任何一个IO操作都能不能一直不停的等待，在指定范围内，都必须让他去执行

#### Block 设备驱动层

Io调度层决定了哪个io请求先执行，哪个io请求后执行，此时可以执行的io请求就会交给Block设备驱动层，经过驱动把iO请求发送给真正的存储硬件，也就是Block设备层

### RAID

第一种、项目的数据读写十分频繁，然后对可靠性要求很高，那这时候毫无疑问肯定选择RAID10了，但是付出的代价也就高了，不过一般这么选择的用户眼都不会眨一下，类似银行，你懂的。

第二种、项目的数据读十分频繁，写则较少一些，然后可靠性有一定要求但不是很高，那么可以选择RAID5，这应该是一种存储性能、数据安全和存储成本兼顾的存储解决方案了，也可以理解为是RAID 0和RAID 1的折中方案。

第三种、项目的读写都十分频繁，但是可靠性要求不高，主要用于内部这种，可以选择RAID0。