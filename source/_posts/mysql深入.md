---
title: mysql（2）
tags:
  - mysql
date: 2021-03-29 14:54:54
top:
---

# 事务

## 常见问题

### 脏写

现在有两个事务A和B，A和B同时在修改一个数据，A先更新，B再更新，但是B回滚了，那么A就是没有写进去，这个数据还是原来的值，这样的情况 称之为脏写

### 脏读

有两个事务A和B，A读取了B已经修改了，但是还没有提交事务的数据，之后B事务回滚了，就会造成A读取的数据和数据库中存储的数据不一样，这样的情况 称之为脏读

### 不可重复读

就是每次读取的数据，都和上次读取的数据不一样

比如一个事务A已经开始事务，读取到了一个数据的值，然后同时一个事务B修改了这数据并且事务提交，那么事务A再次过来查询，就是发现刚才的数据值发生变化了，变成数据B了，如果此时，事务A还没有提交，又过来一个事务C修改了这个数据并且提交，那么事务A再次来查询这个数据就变成了数据C，这种 在一个事务多次查询同一个值，但是查询结果每次都有变化的现象被 称为 不可重复读。

> 不可重复默认就避免了脏读的问题，因为只有在别的事务已经提交之后，当前在查询的事务才能看到新的值

### 幻读

当一个事务，用一个一样的sql进行多次查询之后，结果每次都会看到比上次多一些数据，这种现象被称为 幻读

## 级别

### 未提交

read uncommitted

这个级别的事务，是不允许发生脏写的，也就是说不可能两个数据在没有提交的情况下去更新同一行数据的值，但是在这种隔离的级别下，可能发生脏读，不可重复读，幻读

### 读提交（RC）

read commited

很明显，意思就是一个事务在没有提交的情况下，其他事务是读取不到这个事务的修改之后的值的。

### 可重复读（RR）

> mysql默认的事务级别

这个级别下，不会发生脏写、脏读和不可重复读的问题，因为你一个事务多次查询一个数据的值，那么别的事务修改了这个值并且提交了，但是你还是不会读到其他事务修改过的值，你的事务一旦开始，多次查询一个值，会一直读到同一个值

### 串行化

这个级别的意思就是不会有事务并发执行了，一个一个执行

> 一般生产不会选择这个级别，因为这样数据库的性能太差了

## MVCC

### undolog版本链

![image-20210331111047071](https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210331111047071.png)

上图看起来很简单，无非就是一个新的事务来了，更新这个值，就在undolog版本链上增加一行数据，值更新，txr_id更新为书屋id，roll_pointer指向上一条数据的值

### ReadView

执行一个事务的时候，就会生成一个ReadView

#### 四个参数

- m_ids 这个就是说此时有那些事务在mysql里执行还没有提交
- min_trx_id   就是m_ids里最小的值
- max_trx_id   就是myslq下一个要生成的事务di，就是最大的事务id
- creator_trx_id  就是当前事务的事务id

#### 执行过程

数据库里有一行数据

![image-20210331123304477](https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210331123304477.png)

有两个并发的事务过来了，一个是A，事务id=45，一个B，事务id=59，B是去更新这行数据的，A是去查询这个行数据的

1. A事务生成一个ReadView，
   - m_ids  45,59
   - min_id 45
   - max_id 59 
   - creator_trx_id 45
2. A开始查询数据，A要进行