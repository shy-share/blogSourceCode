---
title: mysql事务
tags:
  - mysql
date: 2021-03-29 14:54:54
top:
---

# 事务

## 常见问题

### 脏写

现在有两个事务A和B，A和B同时在修改一个数据，A先更新，B再更新，但是B回滚了，那么A就是没有写进去，这个数据还是原来的值，这样的情况 称之为脏写

### 脏读

有两个事务A和B，A读取了B已经修改了，但是还没有提交事务的数据，之后B事务回滚了，就会造成A读取的数据和数据库中存储的数据不一样，这样的情况 称之为脏读

### 不可重复读

就是每次读取的数据，都和上次读取的数据不一样

比如一个事务A已经开始事务，读取到了一个数据的值，然后同时一个事务B修改了这数据并且事务提交，那么事务A再次过来查询，就是发现刚才的数据值发生变化了，变成数据B了，如果此时，事务A还没有提交，又过来一个事务C修改了这个数据并且提交，那么事务A再次来查询这个数据就变成了数据C，这种 在一个事务多次查询同一个值，但是查询结果每次都有变化的现象被 称为 不可重复读。

> 不可重复默认就避免了脏读的问题，因为只有在别的事务已经提交之后，当前在查询的事务才能看到新的值

### 幻读

当一个事务，用一个一样的sql进行多次查询之后，结果每次都会看到比上次多一些数据，这种现象被称为 幻读

## 级别

### 未提交

read uncommitted

这个级别的事务，是不允许发生脏写的，也就是说不可能两个数据在没有提交的情况下去更新同一行数据的值，但是在这种隔离的级别下，可能发生脏读，不可重复读，幻读

### 读提交（RC）

read commited

很明显，意思就是一个事务在没有提交的情况下，其他事务是读取不到这个事务的修改之后的值的。

### 可重复读（RR）

> mysql默认的事务级别

这个级别下，不会发生脏写、脏读和不可重复读的问题，因为你一个事务多次查询一个数据的值，那么别的事务修改了这个值并且提交了，但是你还是不会读到其他事务修改过的值，你的事务一旦开始，多次查询一个值，会一直读到同一个值

### 串行化

这个级别的意思就是不会有事务并发执行了，一个一个执行

> 一般生产不会选择这个级别，因为这样数据库的性能太差了

## MVCC

### undolog版本链

![image-20210331111047071](https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210331111047071.png)

上图看起来很简单，无非就是一个新的事务来了，更新这个值，就在undolog版本链上增加一行数据，值更新，txr_id更新为书屋id，roll_pointer指向上一条数据的值

### ReadView

执行一个事务的时候，就会生成一个ReadView

#### 四个参数

- m_ids 这个就是说此时有那些事务在mysql里执行还没有提交
- min_trx_id   就是m_ids里最小的值
- max_trx_id   就是myslq下一个要生成的事务di，就是最大的事务id
- creator_trx_id  就是当前事务的事务id

#### 执行过程

数据库里有一行数据

![image-20210331123304477](https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210331123304477.png)

有两个并发的事务过来了，一个是A，事务id=45，一个B，事务id=59，B是去更新这行数据的，A是去查询这个行数据的

1. A事务生成一个ReadView，
   - m_ids  45,59
   - min_id 45
   - max_id 59 
   - creator_trx_id 45
   
2. A开始查询数据，A要进行判断，判断当前这行的数据的txr_id是否小于ReadView中的min_trx_id,小于最min_trx_id说明你事务开始之前这个事务已经执行完成了，所以可以看到这个事务的结果，也就是这行数数据

3. ![image-20210331195633044](https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210331195633044.png)

   B把这个数据更新了，于是就把B的事务id作为txr_id，B的值也放上去，然后roll_pointer指向原始值

4. 此时A再过来查，还是先和当前txr_id比较，发现trx_id在m_ids之中，就知道这个事务是和自己的事务并发执行的，所以这个结果是读不到的， 于是就顺着链表往下查找，发现32是小于min_trx_id的，知道这行数据是在自己事务之前执行完成的，所以可以读到这行数据

5. 最终读到的数据就是原始值

#### RC

RC的实现其实就是根据undolog版本链和ReadView来构成的，其实每次查询的时候都生成一个ReadView，这样就可以保证，虽然两个事务同时开启，其中一个写的数据先执行成功，另外一个读的事务可以读到修改后的值

> 重点在于：m_ids中代表这还活跃的时候，当发现这个事务的id在min_trx_id和max_trx_id之间，但是不在m_ids中的时候，表示的意思是 两个事务虽然同时开始执行，但是其中一个先提交了，所以另外一个事务可以看到这个事务已经提交的值

#### RR

rr通过undolog版本链和ReadView解决了不可重复读和幻读的问题

解决不可重复读和幻读问题，主要是靠 只 生成一次的ReadView来解决的

还用上面的那个例子来说明

刚开始是有一条原始数据 trx_id为32，然后事务A和事务B同时启动，事务A是查询，事务B是更新数据，在事务A第一次查询的时候，生成一次ReadView

- m_ids  45,59
- min_id 45
- max_id 59 
- creator_trx_id 45

事务A第一次查询，在B事务还没有提交的时候，读取到的是原始值，因为32小于min_id

事务A第二次查询，在B事务已经提交的时候，此时trx_id变为了59，59在 在min_ids中，也在min_id和max_id之间，表示事务A和事务B是同时启动的，所以即使事务B提交了，但是A还是读取不到B修改后的值，读取到的还是原始值

>重点在于：事务id 在min_ids中，也在min_id和max_id之间，表示事务A和事务B是同时启动的，并发启动，无论你事务是否提交，都只能读取到之前已经提交的数据

幻读，也是靠只 生成一次的ReadView来解决的，无论你修改多少回，事务A查询的这个ReadView永远不变，在B之后修改的时候id，肯定要大于B的事务id59，而大于max_id的意思是在之后才执行的事务，所以是读取不到的，所以就往前面找，往前找就到了上面不可重复读的情况，再往上就读取到了  原始数据