---
title: RabbitMQ
tags:
  - RabbitMQ
toc: true
date: 2021-05-20 07:16:18
---

文章摘要

<!-- more -->

### 保证消息不丢失

#### 生产者

通过rabbitmq的一个confirm机制，消息发送到mq之后，将消息持久化到磁盘之后，才会返回confirm给生产者

#### 消费者

rabbitmq默认的是自动ack的机制，但是可能会发生消费者已经收到消息，但是还没有来得及处理消息就宕机的情况，这中情况下，会出现消息丢失的情况

> 自动ack的机制：
>
> 就是消费者只要接收到mq的消息，就会立即返回ack，不管消息是否已经处理完毕

所以采用手动ack机制来确保，消息处理完毕之后，才将ack发送给mq集群

#### 高并发

⾸先，⽤来临时存放未 ack 消息的存储需要承载⾼并发写⼊，⽽且我们不需要什么复杂的运算 操作，这种存储⾸选绝对不是 MySQL 之类的数据库，⽽建议采⽤ kv 存储。kv 存储承载⾼并发 能⼒极强，⽽且 kv 操作性能很⾼。 其次，投递消息之后等待 ack 的过程必须是异步的，也就是类似上⾯那样的代码，已经给出了 ⼀个初步的异步回调的⽅式。 消息投递出去之后，这个投递的线程其实就可以返回了，⾄于每个消息的异步回调，是通过在 channel 注册⼀个 confirm 监听器实现的。 收到⼀个消息 ack 之后，就从 kv 存储中删除这条临时消息；收到⼀个消息 nack 之后，就从 kv 存储提取这条消息然后重新投递⼀次即可；也可以⾃⼰对 kv 存储⾥的消息做监控，如果超过⼀ 定时⻓没收到 ack，就主动重发消息。

### ack机制原理

主要是通过delivery tag

delivery tag是一次消息的唯一标识，delivery tag是在一次channle中传递的

### 消息积压

这个消息积压，主要是当你开启批量处理ack消息的时候，很多消息目前处于unack的情况

RabbitMQ基于一个prefetch count来控制这个unack message的数量。

如果消息的数量小于这个prefetch count，会继续将消息放入这个channel中，如果大于，必须要等待已经投递过去的消息被ack了，此时才能继续投递下一个消息。

prefetch count的这个数量非常重要

- 如果设置过大，会导致mq中存储了海量的数据，会导致消费者服务直接被击垮了，内存溢出，OOM，服务宕机，然后大量unack的消息会被重新投递给其他的消费者服务，此时其他消费者服务一样的情况，直接宕机，最后造成**雪崩效应**。
- 如果设置过小，此时就必然会导致消费者服务的吞吐量极低。因为你即使处理完一条消息，执行ack了也是异步的。

所以鉴于上面两种极端情况，RabbitMQ官方给出的建议是**prefetch count一般设置在100~300之间。**

### 性能优化

#### 批量发送ack消息

