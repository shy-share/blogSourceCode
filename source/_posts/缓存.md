---
title: 缓存
tags:
  - 缓存
date: 2021-03-22 21:14:41
summary:
top:
---

### 经典的缓存架构

可以支持百万流量的三级缓存

![image-20210323211727262](https://gitee.com/flow_disaster/blog-map-bed/raw/master/img/image-20210323211727262.png)

### cache aside pattern

1. 读数据的时候，先读缓存，缓存没有的话，就读数据库，放入缓存，返回响应
2. 写数据的时候，先删除缓存，再更新数据库

>为什么是删除缓存，而不是更新缓存那？
>
>原因很简单，试想这么场景，数据频繁的被修改，那么缓存就也要不断的重新计算，这个计算是非常消耗资源的，而且你更新了这么多次缓存还不一定能用到，就有点得不偿失了，所以就有了先删除缓存，再更新数据的做法，这样就是减少了非常多次的缓存重新计算的工作量，而是用到了数据的时候，再从数据库中加载到缓存中

### 数据库和缓存双写问题

1. 初级

   先写数据库，后写缓存，如果写缓存失败，就会出现数据库和缓存不一致的情况

   >解决方案：很简单，写数据的时候，先删除缓存，再更新数据库就可以了
   >
   >其实就是从两个操作失败的场景来分析就会明白了
   >
   >1. 删除缓存失败，那么就会再次执行删除缓存的操作，可以自定义重试几次，删除换缓存失败的情况，缓存和数据库数据一直，删除缓存成功，会以数据库数据为主，将相应数据写入数据库，等到再次请求缓存，用到这个数据的时候，再将数据放入到缓存中
   >2. 更新数据库失败，更新数据库失败就会回滚，此时缓存中没有数据，以数据库的数据为主，无非就是多次重试执行sql，直到成功或者说规定重试几次，返回更新数据失败的提示

2. 进阶

   看完上面的解释，你是不是以为使用了先删除缓存，再写数据库的方式就可以避免数据库和缓存数据不一致的情况，我在这里告诉你，不是的！

   有一种场景，在一个线程删除缓存成功，准备将数据写数据库的时候，此时另外一个线程来请求这个数据，发现缓存中没有，直接去请求数据库，将数据库的数据读入到了缓存中，然后第一个线程才将数据写入数据库，此时缓存和数据库的数据出现了不一致的情况，数据库中是最新的数据，而缓存中是原来的数据。你以为已经给它删除了，但是如果一个线程出现上述这场景，就和没有删除的情况一样

   